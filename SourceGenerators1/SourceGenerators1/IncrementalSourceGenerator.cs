using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;


namespace SourceGenerators1;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class IncrementalSourceGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";
    private const string AttributeName = "RegisterAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>

namespace {Namespace}
{{
    [System.AttributeUsage(System.AttributeTargets.Class)]
    public class {AttributeName} : System.Attribute
    {{
        public {AttributeName}(Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime)
        {{
            
        }}

        public {AttributeName}(Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime, Type serviceInterface)
        {{

        }}
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the [Register] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.registerAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the [Register] attribute and maps syntax context to the specific node type (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax, bool registerAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;

        // Go through all attributes of the class.
        foreach (var attributeSyntax in classDeclarationSyntax
                     .AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue; // if we can't get the symbol, ignore it

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the [Register] attribute.
            if (attributeName == $"{Namespace}.{AttributeName}")
                return (classDeclarationSyntax, true);
        }

        return (classDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Register] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        List<ClassInformation> classInformations = [];

        // Go through all filtered class declarations.
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = classDeclarationSyntax.Identifier.Text;
            var fullClassName = $"{namespaceName}.{className}";

            var attribute = classSymbol.GetAttributes().First(x => x.AttributeClass.Name == AttributeName);

            var scope = int.Parse(attribute.ConstructorArguments[0].Value.ToString());

            if(attribute.ConstructorArguments.Length < 2)
            {
                classInformations.Add(new ClassInformation(fullClassName, ConvertLifeTimeScope(scope)));
                continue;
            }
            
            var interfaceName = attribute.ConstructorArguments[1].Value.ToString();

            classInformations.Add(new ClassInformation(fullClassName, ConvertLifeTimeScope(scope), interfaceName));
            // Add the source code to the compilation.
        }

        var code = $@"// <auto-generated/>

namespace {Namespace};

internal static class Services
{{
    public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddServices(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
    {{
        {string.Join("\n\t\t", classInformations
            .Select(x => x.ToString()))}

        return services;
    }}
}}
";
        
        context.AddSource("Services.g.cs", SourceText.From(code, Encoding.UTF8));

    }

    private static string ConvertLifeTimeScope(int lifeTime) =>
        lifeTime switch
        {
            0 => "Singleton",
            1 => "Scoped",
            2 => "Transient",
            _ => throw new ArgumentOutOfRangeException(nameof(lifeTime), $"Invalid lifetime value: {lifeTime}.")
        };
}

file class ClassInformation(string className, string lifetime, string? interfaceName = null)
{
    private string ClassName { get; } = className;
    private string LifeTime { get; } = lifetime;
    private string? InterfaceName { get; } = interfaceName;

    public override string ToString()
    {
        return !string.IsNullOrEmpty(InterfaceName) 
            ? $"Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.Add{LifeTime}<{InterfaceName}, {ClassName}>(services);" 
            : $"Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.Add{LifeTime}<{ClassName}>(services);";
    }
}